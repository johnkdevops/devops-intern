**Name**: John Kennedy
**Email**: johnkenn777@gmail.com

---


### Task instructions for DevOps Intern Role

## Note: Running Docker & Kind on Centos Stream 9 VM running on Oracle VirtualBox 7.0 on my local desktop running Windows 10 Pro.

## Prerequisites need to be installed:
Docker
Kubectl
Kind
Terraform 
Helm
Git
Nodejs
NPM
Express
## Must have root permissions on the VM by running sudo su - !!!

## I. Setup a kubernetes cluster using kind

1. To install kind:
 a. curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
 b. chmod +x ./kind
 c. mv ./kind /usr/local/bin/kind
 d. Verify kind is installed run kind --version

2. To install kubectl:
 a. curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
 b. install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
 c. Verify kubectl is installed run kubectl version --client
 
# A. Write a simple bash script that deploys a kind cluster locally
 1. Create the script by running sudo vi deploy-kind-cluster.sh

## Bash Script 

#!/bin/bash
#
# Kind Cluster Deployment
# Author: John Kennedy

# Define the variables
cluster_name="cluster1"
cluster_config="multi-node-config.yaml"


# Create the KinD cluster with the control plane name
kind create cluster --name="$cluster_name" --config="$cluster_config"

# Check if the KinD cluster was created successfully
if [ $? -eq 0 ]; then
    # Obtain the path to the kubeconfig file generated by KinD
    kubeconfig_path=$(kind get kubeconfig --name="$cluster_name")

    # Check if the kubeconfig file exists
    if [ -f "$kubeconfig_path" ]; then
        # Create a directory for Kubernetes configuration files if it doesn't exist
        mkdir -p ~/.kube

        # Copy the kubeconfig file to the default Kubernetes configuration location
        cp "$kubeconfig_path" ~/.kube/config

        # Display a message to inform the user about the successful setup
        echo "KinD cluster created, and kubeconfig file has been copied to ~/.kube/config"
    fi
else
    echo "Error: Failed to create KinD cluster."
fi

## YAML File

kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
name: cluster1
nodes:
- role: control-plane
- role: worker
 
 Steps to run this deploy-kind-cluster bash script:
 1. Give execute permissions to run the script
    sudo chmod +x deploy-kind-cluster.sh
 2. Check permissions on script
    ls -ltr deploy-kind-cluster.sh
    -rwxr-xr-x. 1 root root 343 Sep 21 18:12 kind-cluster.sh
 3. Run bash script: kind-cluster.sh
 ./deploy_kind_cluster.sh
 4. Verify that kind cluster is up and running, I ran kubectl get no
NAME                     STATUS   ROLES           AGE   VERSION
cluster1-control-plane   Ready    control-plane   16m   v1.27.3
cluster1-worker          Ready    <none>          15m   v1.27.3

# B. Download the kubeconfig for the cluster and store in a safe place, we will use it much later in the next steps
 a. Save the kubeconfig of the cluster by running cp /root/.kube/config kubeconfig.config.
 
## II. Deploy a sample Node.js app using terraform

1. Install nodejs & npm by running yum install -y nodejs && yum install -y npm.
 a. Verify version by running node -v
 v16.20.1
2. Create folder by running mkdir app && create a package.json by running npm init -y inside the app folder.

# package.json

{
  "name": "devops-intern-project",
  "version": "1.0.0",
  "description": "A brief description of your project",
  "main": "express.js",
  "scripts": {
    "start": "node express.js",
    "install-express": "npm install express --save"
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "author": "John Kennedy",
  "license": "MIT"
}

3. Install express and create a new file express.js by running npm install express && touch express.js.

# express.js

const express = require('express'); // Import the Express.js framework
const app = express(); // Create an instance of the Express application
const port = 3000; // Define the port number for the server to listen on

// Define a route for the root URL ("/")
app.get('/', (req, res) => {
  res.send('Hello World!'); // Send "Hello World!" as the response
});

// Start the server and listen on the specified port
app.listen(port, () => {
  console.log(`Example app listening on port ${port}`);
});

4. Verify that nodejs express app is up, open new terminal, and run http://localhost:3000
   Hello World!

5. Install docker
 a. sudo yum install -y yum-utils
 b. sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
 c. sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
 d. Start docker run systemctl start docker
 e. Verify that docker is up run systemctl status docker

## A. When kind is up and running, dockerize a simple hello world express and deploy to dockerhub
 
 1. Create the dockerfile inside the app folder by running vi dockerfile

# dockerfile

# Use an official Node.js runtime as a parent image
FROM node:latest

# Set the working directory in the container
WORKDIR /app

# Copy package.json and package-lock.json to the working directory
COPY package.json .

# Install app dependencies
RUN npm install

# Copy the rest of the application source code
COPY . .

# Expose the port your app listens on (e.g., 3000)
EXPOSE 3000

# Define the command to run your application
CMD [ "node", "express.js" ]

 d. Build the docker image by running docker build -t presjkit/hello-world-express-nodejs:v1docker build -t presjkit/hello-world-express-nodejs:v1 . .
 e. Verify the docker image is built by running docker images
REPOSITORY                    TAG       IMAGE ID       CREATED          SIZE
presjkit/hello-world-express-nodejs   v1        35c67f14e997   7 minutes ago   255MB
kindest/node                  <none>    89e7dc9f9131   3 months ago     932MB
 f. Log in to your DockerHub account by using docker login
 g. Push image to DockHub by running docker push presjkit/hello-world-nodejs
 h. Verify the docker image was successfully pushed by going to this link: https://hub.docker.com/repository/docker/presjkit/hello-world-nodejs/

## B. Create a kubernetes deployment manifest to deploy to deploy the Node.js to the kind cluste but don't apply it yet.

1. I used imperative commands to create deployment by running kubectl create deploy hello-world-deployment --image=presjkit/hello-world-nodejs port=3000 --dry-run=client -o yaml > hello-world-nodejs-deploy.yaml

## YAML File

apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: hello-world-deployment
  name: hello-world-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hello-world-deployment
  template:
    metadata:
      labels:
        app: hello-world-deployment
    spec:
      containers:
      - image: presjkit/hello-world-nodejs
        name: hello-world-nodejs
        ports:
        - containerPort: 3000
        resources:
          limits:
            cpu: "0.5"
            memory: 256Mi

## C. using the kubectl terraform provider, write a terraform code to deploy the kubectl manifest to the kind cluster

1. Install terraform:
 a. yum-config-manager --add-repo https://rpm.releases.hashicorp.com/$release/hashicorp.repo
 b. yum install -y terraform
 c. Verify terraform is installed by running terraform --version

2. Create terraform providers by running vi providers.tf

## Terraform HCL Code

provider "kubernetes" {
  config_context = "kind-kind"
}

3. Create terraform main tf file by running vi main.tf

## Terraform HCL Code

resource "kubectl_manifest" "express-node-js-app" {
  yaml_body = file("hello-world-nodejs-deploy.yaml")
}

1. Initalize terraform by running terraform init
2. Plan your terraform configuration by running terraform plan
2. Apply the terraform file by running terraform apply --auto-approve


### Expose the nginx-proxy deployment on port 80.

1. I expose the deployment with dry run by using k expose deploy nginx-proxy-deployment --name=nginx-proxy-service --type=NodePort --port=80 --target-port=80 --dry-run=client -o yaml > nginx-proxy-svc.yaml
2. I would expose the deployment using k apply -f nginx-proxy-svc.yaml
3. I would verify the svc was created for the deployment by using k get svc nginx-proxy-service -o wide
4. I will note what is the NodePort to use: 30576

## YAML File

apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  name: nginx-proxy-service
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: nginx-proxy
  type: NodePort

### Validate the setup by accessing the service. You should observe content from the simple-webapp response.

1. Verify I can get the the simple-webapp application I use curl -I http://localhost:30576
2. I get the 200 OK
3. Verify I can get to nginx-proxy by using curl -I http://localhost:8080.
4. I get the 200 OK
5. Everything up running and working!!
